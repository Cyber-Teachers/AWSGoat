name: 'Terraform Clean Up'

on:
  workflow_dispatch:
    inputs:
      region:
        description: "AWS region (must match the one used for deploy). Leave empty to use AWS_REGION env or eu-west-3 (Paris)."
        required: false
        type: string

permissions: write-all

jobs:
  clean-up:
    name: 'Clean Up Deployments'
    runs-on: ubuntu-latest
    environment: production
    env:
      AWS_ACCESS_KEY_ID: ${{ secrets.AWS_ACCESS_KEY }}
      AWS_SECRET_ACCESS_KEY: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
      AWS_REGION: "eu-west-3"

    defaults:
      run:
        shell: bash

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Terraform
        uses: hashicorp/setup-terraform@v2
        with:
          terraform_version: 1.10.5

      - name: Set Account ID and Region
        id: account
        run: |
          echo "ACCOUNT_ID=$(aws sts get-caller-identity --query Account --output text)" >> $GITHUB_ENV
          REGION="${{ github.event.inputs.region || env.AWS_REGION || 'eu-west-3' }}"
          echo "AWS_REGION=$REGION" >> $GITHUB_ENV
          aws configure set region "$REGION"

      - name: List workspaces (S3 backend keys)
        id: list-workspaces
        run: |
          BUCKET="do-not-delete-awsgoat-state-files-${{ env.ACCOUNT_ID }}-${{ env.AWS_REGION }}"
          aws s3 ls "s3://${BUCKET}/" --recursive --output text 2>/dev/null | awk '{print $4}' | while read -r key; do
            if [[ "$key" == *"/env:/"*"/terraform.tfstate" ]]; then
              mod="${key%%/env:*}"
              rest="${key#*env:/}"
              ws="${rest%%/terraform.tfstate*}"
              echo "$mod $ws"
            fi
          done > workspace_list.txt || true
          echo "Workspaces (module student_id):"
          cat workspace_list.txt 2>/dev/null || echo "(none)"

      - name: Clean up (module-1 and module-2, each workspace)
        continue-on-error: true
        run: |
          BUCKET="do-not-delete-awsgoat-state-files-${{ env.ACCOUNT_ID }}-${{ env.AWS_REGION }}"
          ROOT="$GITHUB_WORKSPACE"

          run_destroy() {
            local mod="$1"
            local sid="$2"
            echo "--- Cleaning up $mod student_id=$sid ---"
            cd "$ROOT/modules/$mod" || return 0
            terraform init -reconfigure -input=false \
              -backend-config="bucket=${BUCKET}" \
              -backend-config="key=terraform.tfstate" \
              -backend-config="region=${{ env.AWS_REGION }}" \
              -backend-config="workspace_key_prefix=${mod}" || true
            terraform workspace select "$sid" 2>/dev/null || true
            terraform destroy -auto-approve -input=false -var="student_id=${sid}" -var="region=${{ env.AWS_REGION }}" || true
            cd "$ROOT" || true
          }

          if [ -s "$ROOT/workspace_list.txt" ]; then
            while IFS= read -r line; do
              [ -z "$line" ] && continue
              MODULE="${line%% *}"
              STUDENT_ID="${line#* }"
              run_destroy "$MODULE" "$STUDENT_ID"
            done < "$ROOT/workspace_list.txt"
          else
            echo "No workspace state found in S3; destroying default workspace for each module."
            for MODULE in module-1 module-2; do
              run_destroy "$MODULE" "default"
            done
          fi
          echo "=== Clean up completed ==="

      - name: Delete state bucket (bootstrap S3)
        run: |
          BUCKET="do-not-delete-awsgoat-state-files-${{ env.ACCOUNT_ID }}-${{ env.AWS_REGION }}"
          if ! aws s3api head-bucket --bucket "$BUCKET" 2>/dev/null; then
            echo "State bucket $BUCKET does not exist; skipping."
            exit 0
          fi
          echo "Emptying versioned state bucket: $BUCKET"
          KEY_MARKER=""
          VERSION_ID_MARKER=""
          while true; do
            args=(--bucket "$BUCKET" --output json)
            [ -n "$KEY_MARKER" ] && args+=(--key-marker "$KEY_MARKER")
            [ -n "$VERSION_ID_MARKER" ] && args+=(--version-id-marker "$VERSION_ID_MARKER")
            out=$(aws s3api list-object-versions "${args[@]}" 2>/dev/null) || break
            echo "$out" | jq -c '.Versions[]? | {Key, VersionId}' 2>/dev/null | while read -r obj; do
              [ -z "$obj" ] && continue
              aws s3api delete-object --bucket "$BUCKET" --key "$(echo "$obj" | jq -r .Key)" --version-id "$(echo "$obj" | jq -r .VersionId)" 2>/dev/null || true
            done
            echo "$out" | jq -c '.DeleteMarkers[]? | {Key, VersionId}' 2>/dev/null | while read -r obj; do
              [ -z "$obj" ] && continue
              aws s3api delete-object --bucket "$BUCKET" --key "$(echo "$obj" | jq -r .Key)" --version-id "$(echo "$obj" | jq -r .VersionId)" 2>/dev/null || true
            done
            truncated=$(echo "$out" | jq -r '.IsTruncated // false')
            [ "$truncated" != "true" ] && break
            KEY_MARKER=$(echo "$out" | jq -r '.NextKeyMarker // empty')
            VERSION_ID_MARKER=$(echo "$out" | jq -r '.NextVersionIdMarker // empty')
            [ -z "$KEY_MARKER" ] && [ -z "$VERSION_ID_MARKER" ] && break
          done
          echo "Deleting bucket: $BUCKET"
          aws s3 rb "s3://${BUCKET}" --force 2>/dev/null || aws s3api delete-bucket --bucket "$BUCKET"
          echo "State bucket deleted."

      - name: Delete all resources tagged Project=AWSGoat
        run: |
          chmod +x scripts/delete-resources-by-tag-awsgoat.sh
          ./scripts/delete-resources-by-tag-awsgoat.sh
        continue-on-error: true
